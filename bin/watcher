#!/bin/bash


function :execute-command-template() {
    local file_name="$1"
    shift

    local command_template="$@"

    sed "s|%s|$file_name|g" <<< $command_template
}

function :eval-command-on-file-name() {
    local file_name="$1"
    shift

    local command=$(:execute-command-template "$file_name" "$@")

    :export-environment "$file_name"

    echo "$ $command"
    (
        eval "$command"
    )
}

function :export-environment() {
    local file_name="$1"

    export FILE=$file_name
    export EXT=$(:get-file-extension $file_name)
}

function :get-file-extension() {
    local file_name="$1"

    sed 's/.*\.//g' <<< "$file_name"
}

function :colorize-output() {
    echo -e '\e[1;44;1;37m'"${@}"'\e[0m'
}

function :is-run-step() {
    local run_number="$1"
    local run_step="$2"
    test $(( $run_number % $run_step )) -eq 0
}

function :wait-changed-files() {
    local events="$1"
    local directory="$2"

    inotifywait -r -m -e $events --format %w%f $directory 2>/dev/null
}

function :parse-opts() {
    local _opts=$1
    local _args=$2

    shift 2

    eval set -- $(getopt -o w:he:d: -- "${@}")
    while [ $# -gt 0 ]; do
        case $1 in
            -w)
                shift
                eval $_opts\[wait\]=$1
                ;;
            -e)
                shift
                eval $_opts\[events\]=$1
                ;;
            -d)
                shift
                eval $_opts\[dir\]=$1
                ;;
            --)
                shift
                break
                ;;
            *)
                ;&
            -h)
                :usage
                exit 1
        esac

        shift
    done

    eval $_args=\$@
}

function :usage() {
        cat <<HELP
Usage:
    watcher [-we] <pattern> [<run_step>] <command>...

Examples:
    $ watcher *.sh
        > will echo modified .sh filename

    $ watcher *.sh bash
        > will run modified .sh filename

    $ watcher -e close_write *.sh bash
        > will run modified .sh filename only on close_write

    $ watcher *.sh 2 bash
        > will run every second .sh filename

Options:
    <pattern>     Used to match file name and run command only if matched.
    <command>     Command to run, '%s' will be replaced with file name.
    <run_step>    Used, if passed as number. Command will run only after
                   <pattern> get matched specified number of times.
    -w <timeout>  Kill task after specified time was passed.
                   Task will be killed with 'TERM'.
    -e <events>   Run specified command only on <events. [default: modify].
                  Most usable are: modify, close_write.
    -d <dir>      Specify directory where watcher should
                   wait for events in. [default: .].
HELP

}

function :watchdog() {
    sleep $1
    kill 2>/dev/null -TERM $(
    pstree -p $2 \
        | grep -o '([0-9]\+)' \
        | grep -o '[0-9]\+'
    )


    :colorize-output "$2 killed after ${1}sec timeout"
}

function :main() {
    local opts
    local args=()

    typeset -A opts

    opts[wait]=0
    opts[events]="modify"
    opts[dir]="."

    :parse-opts opts args "${@}"

    set -- ${args[@]}

    if [ $# -eq 0 ]; then
        :usage

        exit 1
    fi

    if [ "$1" ]; then
        local pattern=${1:-.}
        shift
    fi

    local run_step=1
    if [[ $1 =~ ^-?[0-9]+$ ]]; then
        local run_step=$1
        shift
    fi

    local command="${@:-echo %s}"

    local current_step=0

    :wait-changed-files "${opts[events]}" "${opts[dir]}" \
        | while read file_name; do
        if ! grep -qE "$pattern" <<< "$file_name"; then
            continue
        fi

        current_step=$(( $current_step + 1 ))

        if ! :is-run-step $current_step $run_step; then
            continue
        fi

        if [ $run_step -gt 1 ]; then
            :colorize-output "($current_step % $run_step)" "$file_name"
        else
            :colorize-output "$file_name"
        fi

        if [ ${opts[wait]} -gt 0 ]; then
            ( :eval-command-on-file-name "$file_name" "$command" ) &
            local child=$!

            ( :watchdog ${opts[wait]} $child ) &

            local watchdog=$!

            {
                wait $child
                kill $watchdog
                wait $watchdog
            } 2>/dev/null
        else
            :eval-command-on-file-name "$file_name" "$command"
        fi
    done
}


:main "${@}"
